#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
File storing all necessary function for reading and visualising text
files generated by the Self-propelled Voronoi simulation Cell-GPU.

Created on Wed Mar 16 11:31:01 2022

@author: louis
"""
import numpy as np
from IPython.display import HTML
import matplotlib as mpl
import matplotlib.cm as cm
import matplotlib.pyplot as plt
plt.rcParams["figure.figsize"] = (8,8)
import multiprocessing
import collections
import statistics as stat
import multiprocessing.pool
from IPython.core.debugger import Pdb;
from scipy.spatial import Voronoi, voronoi_plot_2d
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)

"""
Reading and plotting
"""

def ReadFile(file):
    ## File must be a string of where the file to read is
    f = open(file, "r");
    i=0;
    params=[];
    data=[];
    Coord=[];
    while (True):
        line = f.readline();
        #Terminat loop at end of file
        if not line:
            break
        line = line.split();
        #Check if we enconter the line that separates time points
        if line[0]=='N,':
            #Skip the line with N, time, Box and extract the data
            data.append([]);
    i=0;
    f = open(file, "r");
    line = f.readline();
    line = line.split();
    if line[0] == "p0_0":
        params.append(line);
        line = f.readline();
        params.append([float(x) for x in line.split()]);
        line=f.readline();
        line = line.split();
    while (True):
        #Check if we enconter the line that separates time points
        if line[0]=='N,':
            #Skip the line with N, time, Box and extract the data
            #data[i].append([]);
            line = f.readline();
            data[i].append([float(x) for x in line.split()]);
        while line[0]!='N,':
            line = f.readline();
            line = line.split();
            #print(line);
            if not line:
                break
            if line[0]!='N,':
                Coord.append([float(x) for x in line]);
                #Pdb().set_trace();
        data[i].append(Coord);
        Coord=[];
        i = i+1;
        #Terminate loop at end of file
        if not line:
            break
    f.close()
    return data, params

def ReadParams(file):
    f = open(file, "r");
    params=[];
    line = f.readline();
    line = line.split();
    if line[0] == "p0_0":
        params.append(line);
        line = f.readline();
        params.append([float(x) for x in line.split()]);
        line=f.readline();
        line = line.split();
    return params

def CellPos(time, data):
    # Given an index for the time frame, returns from the whole data the positions of the cells 
    Ncells = int(data[time][0][0]);
    cellpos = np.zeros((Ncells,2));
    for i in range(Ncells):
        cellpos[i,0] = data[time][1][i][0];
        cellpos[i,1] = data[time][1][i][1];
    return cellpos

def CellPosTimeInd(data,index,time):
    #Given index as a list of cells "index" to return the trajectories, returns the trajectories
    #for specified "time" frame of the cells specified by index
    #Ncells = int(data[0][0][0]);
    cellpos = np.zeros((len(index),2));
    cellpos[:,0] = [data[time][1][j][0] for j in index];
    cellpos[:,1] = [data[time][1][j][1] for j in index];
    return cellpos;

def CellPosInd(data,index,start):
    #Given index as a list of cells to return the trajectories, returns the trajectories
    #over all time frames of the cells specified by index
    Tf = len(data);
    #Ncells = int(data[0][0][0]);
    cellpos = np.zeros((Tf-start,len(index),2));
    for i in range(start,Tf):
        cellpos[i-start,:,0] = [data[i][1][j][0] for j in index];
        cellpos[i-start,:,1] = [data[i][1][j][1] for j in index];
    return cellpos;

def CellType(time,data):
    #Gives the cell type for each cells given a specific time frame
    Ncells = int(data[time][0][0]);
    celltype = np.zeros(Ncells);
    for i in range(Ncells):
        celltype[i] = data[time][1][i][2];
    return celltype

def CellArea(time,data):
    #Gives the cell area for each cells given a specific time frame
    Ncells = int(data[time][0][0]);
    cellarea = np.zeros(Ncells);
    for i in range(Ncells):
        cellarea[i] = data[time][1][i][3];
    return cellarea

def CellPeri(time,data):
    #Gives the cell perimeter for each cells given a specific time frame
    Ncells = int(data[time][0][0]);
    cellperi = np.zeros(Ncells);
    for i in range(Ncells):
        cellperi[i] = data[time][1][i][4];
    return cellperi

def CellPressure(time,data):
    #Gives the cell perimeter for each cells given a specific time frame
    Ncells = int(data[time][0][0]);
    cellpressure = np.zeros(Ncells);
    for i in range(Ncells):
        cellpressure[i] = data[time][1][i][7];
    return cellpressure

def CellNeighborNum(time,data):
    #Gives the cell perimeter for each cells given a specific time frame
    Ncells = int(data[time][0][0]);
    cellneinum = np.zeros(Ncells);
    for i in range(Ncells):
        cellneinum[i] = data[time][1][i][5];
    return cellneinum

def CellNumOTime(data):
    Ntime = len(data);
    T = np.zeros(Ntime);
    NumCell = np.zeros(Ntime);
    for i in range(Ntime):
        T[i]=SimTime(i, data);
        NumCell[i]=int(data[i][0][0])
    return T,NumCell;

def RunningCellAverage(data):
    Ntime = len(data);
    T = np.zeros(Ntime);
    AverageCell = np.zeros(Ntime);
    for i in range(Ntime):
        T[i]=SimTime(i, data);
        AverageCell[i]=int(data[i][0][6])
    return T,AverageCell;


def SimTime(time,data):
    return data[time][0][1];


def MakeColorPlot(time, data, ax):
    #Plot the voronoi tesselation for a timeframe "time" and color the polygon according to celltype
    cellpos = CellPos(time,data);
    celltype = CellType(time,data);
    T = SimTime(time, data);
    vor = Voronoi(cellpos);
    #Creates a rgb colormap normalized by the cell type range and values
    minima = min(celltype);
    maxima = max(celltype);
    xmin = 5;
    xmax = 15;
    norm = mpl.colors.Normalize(vmin=minima, vmax=maxima, clip=True)
    mapper = cm.ScalarMappable(norm=norm, cmap=cm.jet)
    #fig,ax=plt.subplots();
    #fig = voronoi_plot_2d(vor, show_points=False, show_vertices=False, s=1);
    #fig.set_tight_layout(True);
    #gs=fig.add_gridspec(ncols=2,nrows=2,width_ratios=[20,1],height_ratios=[1,1]);
    #ax=fig.add_subplot(gs[:,0]);
    #ax=fig.add_subplot(111);
    voronoi_plot_2d(vor,ax, show_points=False, show_vertices=False, s=1,point_size=5);
    for r in range(len(vor.point_region)):
        region = vor.regions[vor.point_region[r]]
        if not -1 in region:
            polygon = [vor.vertices[i] for i in region]
            ax.fill(*zip(*polygon), color=mapper.to_rgba(celltype[r]),alpha = 0.5)
            ax.set_xlim(data[1][0][3],data[1][0][2])
            ax.set_ylim(data[1][0][4],data[1][0][5])
            ax.set_title(r'%.2f t.u' %T)
            #ax.set_xticks([])
            #ax.set_yticks([])
            #ax.set_xlim(xmin,xmax)
            #ax.set_ylim(xmin,xmax)
    #ax2 = fig.add_subplot(gs[:,1]);
    #fig.colorbar(mapper,cax=ax2,orientation='vertical',label='types');
    #return ax
    
def MakePressurePlot(time, data, fig, K, Ph, Gamma, alpha):
    #Plot the voronoi tesselation for a timeframe "time" and color the polygon according to celltype
    cellpos = CellPos(time,data);
    celltype = CellType(time,data);
    cellarea = CellArea(time, data);
    kb = np.zeros(len(cellarea));
    al = ['white']*len(cellarea);
    for j in range(len(cellarea)):
        if celltype[j] == 0:
            kb[j] = np.exp(Gamma*(2*K*(cellarea[j]-1) + Ph));
            al[j] = 'blue';
        elif celltype[j] == 1:
            kb[j] = np.exp(Gamma*(2*K*(cellarea[j]-alpha) + Ph))
            al[j] = 'red';
    vor = Voronoi(cellpos);
    #Creates a rgb colormap normalized by the cell type range and values
    minima = min(kb);
    maxima = max(kb);
    xmin = 5;
    xmax = 15;
    norm = mpl.colors.Normalize(vmin=minima, vmax=maxima, clip=True)
    mapper = cm.ScalarMappable(norm=norm, cmap=cm.binary)
    #fig,ax=plt.subplots();
    #fig = voronoi_plot_2d(vor, show_points=False, show_vertices=False, s=1);
    #fig.set_tight_layout(True);
    gs=fig.add_gridspec(ncols=2,nrows=2,width_ratios=[20,1],height_ratios=[1,1]);
    ax=fig.add_subplot(gs[:,0]);
    voronoi_plot_2d(vor,ax, show_points=False, show_vertices=False, s=1);
    for r in range(len(vor.point_region)):
        region = vor.regions[vor.point_region[r]]
        if not -1 in region:
            polygon = [vor.vertices[i] for i in region]
            ax.fill(*zip(*polygon), facecolor=mapper.to_rgba(kb[r]),edgecolor=al[r],linewidth=4)
            #ax.set_xlim(data[1][0][3],data[1][0][2])
            #ax.set_ylim(data[1][0][4],data[1][0][5])
    ax.set_xlim(xmin,xmax)
    ax.set_ylim(xmin,xmax)
    ax2 = fig.add_subplot(gs[:,1]);
    fig.colorbar(mapper,cax=ax2,orientation='vertical',label='birth rate');

def ColorOneCell(time, data, fig, indices):
    #Plot the voronoi tesselation for a timeframe "time" and color the polygon according to celltype
    cellpos = CellPos(time,data);
    celltype = CellType(time,data);
    cellarea = CellArea(time, data);
    xmin=1;
    xmax=4.5;
    ymin=10;
    ymax=14;
    al = ['None']*len(cellarea);
    Al = np.array(al);
    Al[indices] ='red';
    vor = Voronoi(cellpos);
    #fig,ax=plt.subplots();
    #fig = voronoi_plot_2d(vor, show_points=False, show_vertices=False, s=1);
    fig.set_tight_layout(True);
    ax=fig.add_subplot(1,1,1);
    voronoi_plot_2d(vor,ax, show_points=False, show_vertices=False, s=1);
    for r in range(len(vor.point_region)):
        region = vor.regions[vor.point_region[r]]
        if not -1 in region:
            polygon = [vor.vertices[i] for i in region]
            ax.fill(*zip(*polygon), facecolor=Al[r],edgecolor='black',linewidth=1)
    #ax.set_xlim(xmin,xmax)
    #ax.set_ylim(xmin,xmax)
    ax.set_xlim(data[1][0][3],data[1][0][2])
    ax.set_ylim(data[1][0][4],data[1][0][5])
    ax.set_xticks([])
    ax.set_yticks([])

            
